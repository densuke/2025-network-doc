# https

私達は、日常的な通信をほとんど暗号化された回線上で用いるという状況になっています。
この状況は一般に「常時SSL化」と呼ばれています。

なお、ここでは暗号に関して、共通鍵と公開鍵を用いています。これらの概要については、付録に記載のものを参考にしてください。

```{note}
SSLは古い規格であり、現在はTLSが使われています。そういう意味では「常時TLS」が正しいのですが、一般的にSSLという言葉が使われることが多いため、ここでもSSLという言葉を使います。
```

## HTTPSとは

HTTPS(Hypertext Transfer Protocol Secure)は、HTTP over TLS/SSLのことで、HTTP通信をTLS/SSLで暗号化したものです。
HTTPSは、HTTP通信を暗号化することで、通信内容の機密性と完全性を確保します。
また、HTTPSは、サーバーの認証を行うことで、なりすましを防止します。

それぞれの部分について、どのように暗号化を使っているのかを簡単にまとめると、以下のようになります。

- **サーバーの認証**: HTTPSでは、TLS/SSLを使用してサーバーの認証を行います。これにより、クライアントが接続しているサーバーが正当なものであることを確認できます。
- **通信内容の機密性**: HTTPSでは、TLS/SSLを使用して通信内容を暗号化します。これにより、第三者が通信内容を傍受しても、内容を理解することができなくなります。
- **通信内容の完全性**: HTTPSでは、TLS/SSLを使用して通信内容の完全性を確保します。これにより、通信内容が改ざんされた場合に、受信者がそれを検出できるようになります。

それぞれについて、もう少し詳しく見てみましょう。

### サーバーの認証

HTTPSでは、サーバーの認証を行うために、公開鍵暗号方式を使用します。
具体的には、サーバーは証明書を使用して自分の公開鍵をクライアントに提供します。
クライアントは、証明書を検証することで、サーバーの公開鍵が正当なものであることを確認します。
証明書は、信頼できる第三者機関(CA: Certificate Authority)によって発行されます。
クライアントは、CAの公開鍵を使用して証明書を検証します。

まず、サーバーは自分の秘密鍵と公開鍵(鍵ペア)を生成します。
次にサーバーは CSR (Certificate Signing Request) と呼ばれる要求(主体名・SAN・公開鍵などを含む)を作成し、これを認証局(CA) に送ります。公開トラストを得るための証明書はサーバー自身の秘密鍵では署名されず、必ず CA の秘密鍵によって署名されます(自前で署名したものは“自己署名証明書”で、ブラウザには既定で信頼されません)。

クライアントと接続した際、サーバーは「サーバー証明書(+必要な中間証明書チェーン)」と自分の公開鍵(証明書内に埋め込まれている)を提示します。クライアントは“サーバー自身の公開鍵”で証明書署名を検証するのではなく、「証明書の署名者(Issuer)=中間 CA(またはルート CA)」の公開鍵で検証し、さらにその中間 CA 証明書を上位の CA へと遡って最終的にルート証明書が信頼ストアに存在するかを確認します。これにより提示された公開鍵が正当(改ざんされておらず、所定のドメインに結び付く)であると判断できます。

### 信頼の鎖(Trust Chain)

前節で述べたように、クライアントは証明書と一緒に渡った公開鍵で証明書の署名検証を行います。
しかしここで疑問も生じます。クライアントは本当にその公開鍵を信用できるのでしょうか?

この問題を解決するために、httpsにおいては「信頼の鎖(Trust Chain)」という仕組みが使われています。
信頼の鎖は、証明書が信頼できるものであることを確認するための仕組みです。
信頼の鎖は、以下のように構成されます。

1. **ルート証明書**: これは、信頼できる第三者機関(CA)によって発行される証明書です。ルート証明書は、クライアントに事前にインストールされており、信頼の基点となります。
2. **中間証明書**: これは、ルート証明書によって発行される証明書です。中間証明書は、ルート証明書とサーバー証明書の間に位置します。
3. **サーバー証明書**: これは、中間証明書によって発行される証明書です。サーバー証明書は、サーバーの公開鍵とサーバーの情報を含みます。

クライアントは、サーバーから受け取ったサーバー証明書を検証するために、以下の手順を実行します。

1. サーバー証明書の署名を発行した中間 CA 証明書の公開鍵で検証します(署名アルゴリズム一致・改ざん検出)。
2. 中間 CA 証明書の署名をさらに上位(別の中間またはルート)で検証し、最終的にルート証明書へ到達するまで繰り返します。
3. ルート証明書がクライアントの信頼ストアに存在し、有効期限内で失効(CRL/OCSP)が無いことを確認します。
4. サーバー名(ホスト名)が証明書の SubjectAltName (SAN) に含まれているか照合します。

これにより、クライアントはサーバー証明書が信頼できるものであることを確認できます。

```{note}
なお、中間証明書なしに、いきなりルート証明書がサーバー証明書を発行することも技術的には可能ですが、ルート証明書の秘密鍵が漏洩した場合に大規模な影響が出るため、実際には中間証明書を使うことが一般的です。
```

### 証明書の中身は何が入っている？

典型的な X.509 サーバー証明書には次のようなフィールドが含まれます。

- Version: 証明書フォーマットのバージョン(通常 v3)
- Serial Number: 発行CA内で一意となる番号
- Signature Algorithm: この証明書(TBSCertificate部分)に対して CA が用いた署名アルゴリズム(例: sha256WithRSAEncryption, ecdsa-with-SHA384 など)
- Issuer: 発行者(CA)の識別名 (DN)
- Validity: 有効期間(Not Before / Not After)
- Subject: 証明書の主体(サーバー)の識別名 (DN)
- Subject Public Key Info: 主体の公開鍵アルゴリズムと公開鍵ビット列
- Extensions: SAN(Subject Alternative Name), Key Usage, Extended Key Usage, Basic Constraints, CRL Distribution Points, Authority Information Access など
- Signature (Value): 上記 TBSCertificate(署名対象部分)全体に対する CA の秘密鍵で生成した署名値

ポイント: 証明書本体(TBSCertificate)と、そのハッシュに対して作られた署名値を組み合わせたものが最終的な証明書構造です。公開鍵や SAN など“主体の情報”は署名『の中身』ではなく「署名対象データ」であり、改ざんすれば署名検証が失敗します。

### 署名が施される流れ(概念)

以下はサーバー証明書が中間 CA によって署名されるまでの流れを簡略化した概念図です。内部的な用語が多いので“雰囲気”を掴むだけでも問題ありません。

```{mermaid}
sequenceDiagram
    participant S as サーバー
    participant CAi as 中間CA
    participant CAr as ルートCA

    S->>S: 鍵ペア生成 (server_sk, server_pk)
    S->>S: CSR作成 (Subject, SAN, server_pk,...)
    S->>CAi: CSR送付
    CAi->>CAi: CSR検証 (ポリシー/ドメイン実在性等)
    CAi->>CAi: TBS(Certificate情報)生成
    CAi->>CAi: ハッシュ=Hash(TBS)
    CAi->>CAi: 署名=Sign_CA_i(hash)
    CAi-->>S: サーバー証明書 (TBS + 署名)
    note over CAi,CAr: 中間CA証明書自体は CAr の秘密鍵で署名済み
```

### 証明書検証(クライアント側)

クライアントがサーバー証明書を検証する手順をシーケンスで表します。


```{mermaid}
sequenceDiagram
    participant Client as クライアント
    participant Server as サーバー
    participant CAi as 中間CA
    participant CAr as ルートCA

    Client->>Server: ClientHello
    Server-->>Client: ServerHello + サーバー証明書 + 中間CA証明書
    Client->>Client: TBSを抽出 / 署名アルゴリズム確認 / 有効期限確認
    Client->>Client: hash=Hash(TBS)
    Client->>CAi: チェーン内から中間CAの公開鍵を取得
    Client->>CAi: サーバー証明書署名検証 (Verify(signature, hash, CAi_pub))
    alt 署名検証が成功
    Client->>CAr: 中間CA証明書の署名検証 / 失効確認
    CAr-->>Client: ルート証明書は信頼ストア内
        Client->>Server: 鍵共有処理へ進行 (ECDHE 等)
    else 署名検証が失敗
        Client-->>Server: 接続を中止 / エラー
    end
```

### 通信内容の機密性(鍵共有と前方秘匿性)

HTTPSでは、TLS/SSLを使用して通信内容を暗号化します。
これにより、第三者が通信内容を傍受しても、内容を理解することができなくなります。
TLS では最終的に「対称鍵(レコード暗号用セッション鍵)」でアプリケーションデータを暗号化します。セッション鍵自体はハンドシェイクで安全に合意され、TLS 1.3 では ECDHE(楕円曲線 Diffie-Hellman)を必須として“前方秘匿性 (Forward Secrecy)”を確保します。過去の TLS 1.2 以前では RSA 鍵交換(前方秘匿性なし)もありましたが現行では非推奨です。

TLS 1.3 ではハンドシェイクの各段階(Early / Handshake / Application)で秘密が段階的に派生し、さらに必要に応じて KeyUpdate メッセージで“再鍵装”が可能です。これにより長時間同じ鍵を使い続けるリスクが軽減されます(TLS 1.2 以前は実運用で頻繁な鍵更新は少なく、再接続や再ネゴシエーションで更新する形が主流でした)。

```{note}
悪意のある監視者は、長時間通信内容を(暗号化されていても)傍受し、蓄積して解析します。
このときに、長期間同じ鍵を用いた暗号化を用いていると、内容から類推ができてしまう恐れがあり、その分解読されるリスクが高まってしまいます。
よって、定期的に鍵の更新を行うことで、そのリスクを下げるようにしています。
```

### 通信内容の完全性(改ざん検出)

HTTPSでは、TLS/SSLを使用して通信内容の完全性を確保します。
これにより、通信内容が改ざんされた場合に、受信者がそれを検出できるようになります。
旧来(TLS 1.2 の一部まで)の暗号スイートでは “MAC-then-Encrypt (HMAC + CBC)” 方式が使われていました。現行で推奨されるスイート(AES-GCM, ChaCha20-Poly1305 など)は AEAD (Authenticated Encryption with Associated Data) を用い、暗号化と完全性検証を一体化します。TLS ハンドシェイク自体も Finished メッセージでトランスクリプト全体のハッシュを鍵付きで検証し、改ざんを防ぎます。

### (補足)クライアント認証

通常はサーバー認証のみですが、双方向認証が必要な環境ではクライアント証明書を提示し、サーバーがその証明書チェーンと署名を検証することでクライアント実体を確認します。

## 常時SSLと"Let's Encrypt"プロジェクト

もともとのウェブサイトでは、大半のサイトが非暗号化(http)で運用されていました。
ですが、認証の必要なページや、個人情報を扱うページなどでは、通信の盗聴や改ざんを防ぐために暗号化が必要とされていました。
このように分かれていたのは、SSLやTLSの導入が簡単ではなかったということと、証明書の取得(ルート証明書がOSに含まれるようなところから購入する)という行為はそれ相応に金額が発生するためです。
もちろん、信頼の置ける企業による証明書は必要ですが、個人のブログや小規模なサイトでは、そこまでの信頼性は必要ない場合も多いです。

```{note}
実際筆者(佐藤)もそういうところから証明書にサインをしてもらっていましたが、当時では年額3000円ほどで、別に高いと言うほどでもありませんでした。
またそういうサインを使わない「自己署名証明書」というものもありましたが、これはブラウザが既定で信頼しないため、警告が出てしまい実用的ではありませんでした。
ちなみに自己署名証明書については「オレオレ証明書」と呼ばれることもありました。
```

このような状況を変えたのが、"Let's Encrypt"プロジェクトです。
このプロジェクトは、無料で証明書を発行することを目的としており、2016年にサービスを開始しました。
Let's Encryptは、ACME(Automatic Certificate Management Environment)プロトコルを使用して、証明書の発行と管理を自動化しています。
これにより、証明書の取得と更新が非常に簡単になり、多くのウェブサイトがHTTPSを採用するようになりました。
現在では多くのシステム(ブラウザなど)で、信頼できるルーツ証明書の一つとしてLet's Encryptが発行した証明書が含まれています。

たとえば、CaddyというWebサーバー実装では、利用可能なホストに対する証明書を自動的に取得し、更新する機能が組み込まれています。