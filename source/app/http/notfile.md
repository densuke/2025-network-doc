# リクエストとファイルは関係ないという事実

HTTPを単純に使うと、主に静的なファイルに対する送受信をイメージしがちです。
ですが、実はそれは誤ったイメージです。
実際は、リクエストとファイルパスに関しての関連性は特にありません。
イメージしやすいし、用途として実際に使っているのでそうなっているだけです。

## 静的ファイル送受信という意味での利用

静的ファイル送受信という目的においては、一般的に **ドキュメントルート(Document Root)** というものが重要視されます。これは、リクエストにあったパスをサーバー上のドキュメントに変換するための基底部と考えられます。

わかりやすい例として、Apache httpd(デファクトスタンダード的扱いのWebサーバー実装)の設定を見てみましょう。

```{code-block}
:language: bash

$ sudo apt update
$ sudo apt install -y apache2 # Apache HTTP Serverをインストール
$ cat /etc/apache2/sites-available/000-default.conf | grep DocumentRoot
    DocumentRoot /var/www/html # ここがドキュメントルート
$ ls /var/www/html             # そのディレクトリをチェックすると…
index.html                     # 実際にファイルがある
```

この場合、仮にサーバー名が `example.com`の場合、 `http://example.com/index.html` にアクセスすることで、`/var/www/html/index.html` にアクセスすることになります。

## パスがディレクトリとみなされる場合の対応

リクエストされたパスがディレクトリであるとみなされる場合、Webサーバーは通常、そのディレクトリ内の `index.html` などのデフォルトのファイルを返します。これにより、ユーザーは明示的にファイル名を指定しなくても、ディレクトリにアクセスできるようになります。
なお、 **この処理はHTTPの仕様ではなく、あくまでWebサーバー上での実装に基づきます** 。そのため、実際に読み込まれるファイルがなんなのかはWebサーバーの設定次第となります[^implicit_content]。

[^implicit_content]: 実際のところとしては、`index.html`がまずチェックされ、無ければ`index.htm`(古いwindowsの名残で拡張子3文字しか対応していないケース)、それでもなければ`index.txt`(プレインテキスト)といった具合にチェックされます。

## 対象となる拡張子の追加

たとえばPHP言語のように、サーバー上で動的にコンテンツを生成するシステムを組み込んだ場合、それがわかるようにするために、ファイル名の末尾(いわゆる拡張子)を言語に合わせて設定する必要があります。
すなわち、指定の拡張子のファイルがマップされた場合に、その拡張子に対応した処理を行えるシステムに処理を委譲するという形をとります。

```{mermaid}
sequenceDiagram
    participant ブラウザ as ブラウザ
    participant Webサーバー as Webサーバー
    participant PHPランタイム as PHPランタイム

    ブラウザ->>Webサーバー: HTTPリクエスト (例: /index.php または /style.css)
    alt 静的ファイルの場合
        Webサーバー->>Webサーバー: ドキュメントルートでファイルを探索
        Webサーバー-->>ブラウザ: 静的ファイルを返す (200 OK)
    else 動的(PHP)の場合
        Webサーバー->>PHPランタイム: FastCGI/HTTPプロキシでスクリプト実行要求
        PHPランタイム->>PHPランタイム: PHPスクリプト実行(DB/キャッシュ呼び出しなど)
        PHPランタイム-->>Webサーバー: レンダリング済みレスポンスを返す (ヘッダ+ボディ)
        Webサーバー-->>ブラウザ: クライアントへHTTPレスポンスを返す
    end
```

Apache httpdの場合、PHPにどう渡すかについては大きく2つの考え方が存在します。

- httpd自体にPHP言語ランタイムを組み込む(prefork)
  - 内部的に渡すだけのため呼び出しが高速ですが、httpd自体のプロセスが肥大化します。
- httpdからソケット通信で起動しているPHP言語ランタイムにリクエストを委譲する(worker/event)
  - リクエストを別プロセスに渡すため、httpdのプロセスは軽量ですが、呼び出しにかかるオーバーヘッドが増加します。
  - ただしリクエストで使用するコード自体は共有されるため、メモリ使用量は抑えられますし、一度動かしているコード(かつ変更無し)ならばキャッシュされているためにすぐに機能するようになっています。

一般的なPHPのコードはどちらの方式でも対応しているため、開発時はpreforkモードで手軽に開発を行い、運用時はworker/eventで動かすといった処理も可能です。


## パスとファイルが一致しない場合

たとえばAPIサーバーのように、実際のファイルは存在せずに、HTTPリクエストにおけるパスにより対応を振り分けるといったケースも非常に多いです。
たとえば、以下のようなパスを持つAPIがあるとします。

- http://example.com/api/users
- http://example.com/api/products/42

この時、受け取ったWebサーバー側がパス(`/api/users`や`/api/products/42`)を一旦解釈します。
そしてそのパスに見合ったプログラムを呼び出すことで、適切なレスポンスを生成することも可能です。

- `/api/users` -> ユーザー一覧をJSONで返す
- `/api/products/42` -> 商品IDが42の商品の詳細をJSONで返す

この場合、リクエストに応じて都度プログラムが実行されると、Pythonのようなインタプリタ型を伴う言語では応答が悪くなる恐れがあります。そのため、事前にスクリプトを起動した状態にしておき、バックエンドで呼び出すことが多いです。
この呼び出し方はある程度標準化されており、FastCGIやHTTPプロキシを使うことが多いです。

```{mermaid}
sequenceDiagram
    participant ブラウザ as ブラウザ
    participant Webサーバー as Webサーバー
    participant Pythonランタイム as Pythonランタイム<br/>(起動済み)

    ブラウザ->>Webサーバー: HTTPリクエスト (例: /api/users)
    Webサーバー->>Pythonランタイム: FastCGI/HTTPプロキシでスクリプト実行要求
    Pythonランタイム->>Pythonランタイム: スクリプト実行(DB/キャッシュ呼び出しなど)
    Pythonランタイム-->>Webサーバー: レンダリング済みレスポンスを返す (ヘッダ+ボディ)
    Webサーバー-->>ブラウザ: クライアントへHTTPレスポンスを返す
```

最近では、クライアント(ブラウザ)側でJavaScriptによる動的なページレンダリングをしつつ、裏側で部品となる情報をAPIリクエストでやりとりして、取得したデータに基づいてページを書き換えていくという方式が一般的です。
X(旧Twitter)やInstagram、GMailなどの主要なWebサービスはこのような方式で動いています。
特にこの方式でURLが変わらずにページ内容が書き換わっていく動きについては、SPA(Single Page Application)と呼ばれています。

```{note}
PWA(Progressive Web Apps)という、Webアプリケーションをネイティブアプリケーションのように振る舞わせる技術もあります。SPAの応用で実現されており、オフラインでの動作やプッシュ通知なども可能です。

また、スマートフォンアプリについても、ネイティブアプリケーションの中でWebViewコンポーネントを用いてWebページをアプリの一部として組み込むという運用も存在し、現状ではあまり出てきませんが一時「皮(がわ)ネイティブ」と表現されることもありました(最近はほとんど聞きません、現在はほとんど使われない俗語です)。
```

## データ生成はいつ行うのかという問題

現代のWebページ(Webアプリケーション)は、静的なHTMLはもちろんありますが、かなりの部分が動的に生成されたものとなっています。
それだけ利用者の情報(アカウントやアカウントに紐付けられた個人情報、その他の関連事項)に応じた個別化(パーソナライズ)されたものが求められるようになっています。

### データ生成の功罪

ユーザーのアクセスに応じたページ生成は、利用者にとって(そのサイトで)必要な情報へ行き着きやすくなる(もしくは誘導できる)という利点があります。
これが商売のページであれば、購買行動に繋がるようになっていれば成功です。

その一方で、都度ページを生成するという行為は、サーバーに対する負荷という部分で問題が生じる可能性があります。
そのため『静的に生成できる部分』と『動的に生成する部分』をきちんと分離し、適切な処理を行う必要があります。
さらにサイトとしてのレイアウト(体裁)も維持する必要が生じます。
そこで動的サイト生成のシステムでは、一般に『テンプレートエンジン』と呼ばれる仕組みを導入します。
以下の例はPythonで実装されているライブラリJinja2の例です。HTMLの中に、 `{%` と `%}` で囲まれた制御構文、 `{{` と `}}` で囲まれた変数埋め込みを行うことができます。

```{code-block}
:caption: Pythonでの実装: Jinja2の例

{% if user.is_authenticated %}
    <p>Welcome, {{ user.username }}!</p>
{% else %}
    <p>Please log in.</p>
{% endif %}
```

ざっくり見るだけでも、ユーザーが認証されているかどうかで表示内容を変えたり、ユーザー名を埋め込んだりできることがわかります。

当然このようなテンプレートエンジンを使うには、サーバー側でテンプレートエンジンを保有する必要があり、リクエストの中で都度使っていく必要が生じます。その分少量でもサーバーへの負荷が増大することになります。
もし人気のあるサイトとなってしまえば、非常に多くのリクエストに同時並行して対応する必要があり、サーバーの負荷が非常に高くなることもあります。
コストが許すのであれば、サーバー(インスタンス)の性能を引き上げたり、サーバーを増やして分散するなどの対応も必要になることでしょう。

同様の事例は、オンラインゲームのAPIサーバーも該当するでしょう。こちらはむしろ多くが動的なデータとなります。各ユーザーからの情報を集約し、必要に応じて処理したデータをユーザーに返していくことが常時行われていきます。
当然一定の性能が保持できないと、利用者側にとっては遅延といった形で不利益が生じる可能性も出てきます。どれぐらいの性能のサーバーを持たせるべきかなどをαテスター、βテスター達の意見を参考にして、負荷試験を行いながら決定していくことになるでしょう。

### SSGによる負荷低減

もしそこまで個人ごとのパーソナライズが必要が無いという状況であれば、SSG(Static Site Generator; 静的サイトジェネレーター)を用いることも検討できます。
たとえばブログのサイトであれば、従来はリクエストに応じた動的レンダリング(WordpressやMovableType)が主流です。しかし、最近ではSSGを用いて事前に静的なHTMLに変換することで、サーバー側は単純にファイルを返すだけで済むようになって負荷が大幅に低減します。

ただし、完全に静的になるとユーザーが離脱する恐れがあるため、動的な処理をJavaScriptで補っていることも多いです。

- 外枠(レイアウト)は静的に生成
- 内部コンテンツを断片化して静的に生成
- ブラウザには外枠と内部コンテンツの組み合わせを行うJavaScriptを配信
- ブラウザ側でのスクリプトにより、必要に応じて内部のコンテンツを送信し、レンダリングさせる

こうやって見ると、サーバー側が全てを負担するというよりは、クライアント側にも負担をさせている(分散させている)という風に見ることもできますね。

```{note}
もちろん静的サイト生成を行うというコストは発生します。
ただしこれは一度だけ行えば良く、なんなら生成処理自体はバックグラウンドで(指定の〆切りまでに)行えればそれでかまいません。
よって、サーバー自体の負荷としてはかなりマシな話となります。
```

```{note}
ブログサイトなんかでは、広告部分やアクセス解析のツールをJavaScriptを用いて読み込ませるという方法を取り、配信しているサイト自体はできる限り静的にしていることが多いです。
その結果、サーバーの負荷が大幅に低減され、コストも抑えられています。
```
