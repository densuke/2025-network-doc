# NTP とは

NTP (Network Time Protocol) は、インターネット上でコンピューターの時刻を正確に同期させるためのプロトコルです。
NTP は 1985 年に開発され、その後も改良が続けられています。NTP は、階層構造を持つサーバー群を利用して、正確な時刻情報を提供します。

NTP は、主に以下のような仕組みで動作します。

```{note}
この部分はNTPの理解を助けるためのものです。
小難しい計算が入るのでざっくり『往復のやり取りの中で遅延とオフセットを推定して補正する』というイメージを持ってください。
```

1. **階層構造**: 参照時計 (Stratum 0) はサーバーではなく原子時計や GPS 等の高精度な時刻源です。Stratum 1 サーバーは参照時計に直結して時刻を配布し、Stratum 2/3… と下位層がそれらから同期します (層が下がるほど N 値が大きくなります)。
2. **時刻同期**: NTP クライアントはサーバーと 4 つの時刻スタンプ T1..T4 を交換し、オフセットと遅延を推定してシステムクロックを調整します。

	$$\text{offset} = \frac{(T_2 - T_1) + (T_3 - T_4)}{2} \quad,\quad \text{delay} = (T_4 - T_1) - (T_3 - T_2)$$

	(対称遅延を仮定した基本式。実装ではフィルタリングや重み付けが加わります。)

	T1..T4 の意味 (ざっくり):

	- T1: クライアントが要求を送信した時刻
	- T2: サーバーが要求を受信した時刻
	- T3: サーバーが応答を送信した時刻
	- T4: クライアントが応答を受信した時刻

	```{tip}
	式は「こういう足し引きでズレを見積もっている」程度の理解で十分です。暗記や手計算は不要です (実装が面倒を見てくれます)。
	```
3. **補正アルゴリズム**: NTP はネットワーク遅延やジッターを考慮し、複数サンプルのフィルタリングや PLL/FLL による“ならし”で安定して追従します。

## 遅延について

- NTP クライアントとサーバーは別ホストであるため往復遅延が存在します。NTP は T1..T4 から遅延・オフセットを推定し、対称性の仮定の下で補正量を決めます。
- 実ネットワークでは往路/復路が非対称なことが多いため、単発では誤差が出ます。そこで複数サンプルの統計処理 (外れ値除去、重み付け) で近似的に最良の推定を行います。

## ジッターについて

- ジッターはネットワーク遅延のばらつきです。NTP はサンプルを蓄積し、統計的に変動を平滑化して安定した時刻推定を行います。

## NTPの精度について

一般的な目安として、LAN 内ではサブミリ秒〜数ミリ秒、インターネット越しでは数十ミリ秒程度に収まることが多いです (回線品質・経路・実装設定に依存). SNTP や不安定回線では精度が劣る場合があります。

```{note}
リープ秒は NTP で告知され (LI ビット等)、UTC に追随します。NTP のエポックは 1900-01-01 です。高精度が必要な用途では PTP (IEEE 1588) も検討されます。近年の一般的な実装には `chronyd`、`systemd-timesyncd`、`ntpd` などがあります。
```

## 強制的な補正をするべきか否か

NTP のクライアントは、大きく2つのタイプがあります。

- 強制的に今の時刻を変更するタイプ(step)
- 徐々に時刻を調整するタイプ(slew)

前者（step; 一気に時刻を「飛ばす」）は主にクライアント端末で、起動直後など大きなズレがある場合に使われます。なお、歴史的には `ntpdate` が使われてきましたが、現在は非推奨です。代替としては `chronyd`（`chrony`）や `systemd-timesyncd` を推奨します。

その一方で、サーバーにおいてはあまり強制的な変更は望ましくありません。
これを行った場合『飛ばされた時間に実行予定だったタスク』が動いていない状態となるため、最悪『遅延したすべてのタスクが一斉に動き出す』、あるいは時刻を戻すと重複実行・ログの順序崩れ等の問題が発生するおそれがあります（多くのスケジューラや有効期限判定が `CLOCK_REALTIME` に依存します）。

そのため、サーバー向けの NTP クライアント（`ntpd` や `chronyd` など）は、基本的に「徐々に時刻を進めたり遅らせたり（slew）」して補正します。こうすることで、システムの時間が段階的に正しくなり、タスクの実行漏れや重複のリスクを低減できます。

```{note}
step と slew の基本

- slew: 小刻みに周波数を変えて時刻を追いつかせる（一般的に最大 ~500 ppm 程度）。安全だが収束に時間がかかる。
- step: 時刻を即座にジャンプさせる。大きなズレをすぐ解消できるが、タスクやログ時系列に影響。

実装の例:

- `ntpd`: 既定では大きなオフセット（およそ 128 ms 超）で初期化直後に step を行い、以降は原則 slew を用います。
- `chronyd`: 設定で起動直後のみ大きなズレに対して step を許容できます（例: 下記 `makestep`）。通常運用中は slew を使用。

設定例（chrony）:

```text
# /etc/chrony/chrony.conf
makestep 1.0 3   # 初期同期で 1秒超のズレが3回以内に観測されたら step を許容
```

運用指針としては、起動直後やレジューム直後など「大きなズレが発生しやすい瞬間」に限って step を許容し、平常時は slew を基本とするのが安全です。
```

補足: Linux の `CLOCK_MONOTONIC` はリアルタイム時刻の step では巻き戻りませんが、アプリケーションやジョブスケジューラの多くは `CLOCK_REALTIME` を前提にしているため、やはり step は慎重に扱う必要があります。