# UDPのサーバーを作ってみる

つづいて、サーバー側を見てみましょう。
こちらは逆であり、クライアント側からのデータを受け取っての処理となります。

## UDP echoサーバー

ファイル名はクライアント側にならって、`echo-server.py`とします。

```{literalinclude} sources/echo/echo-server.py
:language: python
:linenos:
```

サーバー側でもソケットを作る部分は同じですね。

### 待ち受け

相手が自身の10000/udpにデータを投げつけてくることになるので、そこに対して待機しておかないといけません。
この行為は、`bind`(バインド、結びつける)と呼ばれます。
プログラム(プロセス)を指定ポートに結びつけることで、入ってきた情報をそのままプロセスに渡してもらおうというイメージです。

```{literalinclude} sources/echo/echo-server.py
:language: python
:lines: 9-10
:emphasize-lines: 2
```

バインド先の指定は、タプルを用いて接続先ホスト(自身の持つIPアドレスのいずれか)とポート番号となります。

```{note}
`('', 10000)`のようにIPアドレス指定部分を空文字列を指定することで、すべてのIPアドレスで待ち受けることができます。
```

### データの受信

届いたデータは、`recvfrom`メソッドを使って受信します。

```{literalinclude} sources/echo/echo-server.py
:language: python
:lines: 16-17
:emphasize-lines: 2
```

`recvfrom`はクライアント側での折り返し受信にて既に説明済みです。送る側も受ける側もおおむね同じ事をしているという所もわかりやすくていいですね。

このコードでは、折り返しの送信を行っているため、受け取ったデータをそのまま`sock.sendto()`にて送り返しています。

## 実際に走らせてみよう

両ファイルの保存を確認したら、ターミナル上で起動してみます。
今回は2つの端末を使うことになるので、『ターミナルの分割』を使って左右でクライアント・サーバーという形にするといいでしょう。

サーバー側をまず起動してみます。

```bash
uv run echo-server.py
```

すると、以下のメッセージが出て待機状態に入ります。

```
サーバーは ('localhost', 10000) で待ち受けています
```

次にクライアント側の起動です。

```bash
uv run echo-client.py
```

こちらは即座に動き、以下のような出力となります。

```
送信内容: b'Hello, World!'
応答待ち
受信しました: b'Hello, World!'
終了します
```

そしてサーバー側でも応答が追加されます。

```
受信しました: b'Hello, World!' from ('127.0.0.1', 35270)
送信しました: b'Hello, World!'
```

このように、クライアント側から送られたデータを受け取り、そのまま返信していることがわかります。

## サーバーが動いていなかったら?

UDPでは相手のサーバーが受付可能なじょうたいであるかの確認は事前には行いません(『投げる』でしたね)。そのため、サーバー側を止めても送信行為は可能です。

- `echo-server.py` 側を停止させる({kbd}`Ctrl+C`)
- `echo-client.py` 側を起動させる

すると、応答待ちでクライアント側が停止してしまいます。


```
送信内容: b'Hello, World!'
応答待ち
```

確認できたら、{kbd}`Ctrl+C`でクライアント側も停止させておきましょう。そのため、クライアント側では送信の可否判定が直接行えないことがわかります。そのため、送信タイムアウトを設けて適当なタイミングでエラー終了とさせておくといいでしょう。

```{literalinclude} sources/echo/echo-client-timeout.py
:language: python
:linenos:
:diff: sources/echo/echo-client.py
```

このように、送信の可否を自分できちんと判定する必要があることもまたUDPの特徴となります。
