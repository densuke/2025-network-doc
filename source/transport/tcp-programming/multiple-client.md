# 複数の接続に対応するには?

サーバー側の現在の実装では、1つのクライアントとの接続しか処理できないことがわかりました。
ではこのような問題に対応するにはどうしたらいいでしょうか。

## 複数のクライアントに対応する方法

1つのサーバーで複数のクライアントからの接続を同時に処理するためには、以下の方法があります。

- **プロセスを使う**: 各クライアントの接続を別々のプロセスで処理します。これにより、各プロセスが独立して動作し、同時に複数のクライアントを処理できます。
- **スレッドを使う**: 各クライアントの接続を別々のスレッドで処理します。これにより、同時に複数のクライアントからのリクエストを処理できます。
- **非同期I/Oを使う**: Pythonの`asyncio`モジュールを使って、非同期にクライアントの接続を処理します。これにより、I/O待ちの間も他のクライアントの処理が可能になります。

プロセスやスレッドは、OSにおけるプログラムの実行単位というレベルの話になります。

プロセスは、それぞれが独立した状態です。
そのため、プロセス間でデータの共有や受け渡しを行うためにはなんらかの準備が必要となります。
逆に言えばそれだけ独立性が高く、1つのプロセスがクラッシュしても他のプロセスには影響しにくい構造になっています。

スレッドは、同じプロセス内で小分けにされたような感じで考えてください。
そのためスレッド間のデータはプロセス内で共有された形になります。
処理はしやすくなる反面、共有しているデータに対するアクセス方法[^thread-safe]に注意が必要です。

```{mermaid}
sequenceDiagram
    participant Thread1 as スレッド1
    participant Thread2 as スレッド2
    participant Shared as 共有データ

    Thread1->>Shared: 書き込み(更新)
    Thread2->>Shared: 読み取り(同時アクセス)
    Note over Thread1,Thread2: レースコンディション発生
```

```{note}
レースコンディション: 複数のスレッドが同時に共有データにアクセスし、予期しない結果を引き起こす状態を指します。
```

[^thread-safe]: 具体的には共有しているデータ(メモリ)に対する書き込みが該当します。どこかのスレッドで書き込み中に他のスレッドが読み書きすると、データが壊れる可能性があります。

レースコンディションを防ぐためには、共有するデータに対して『今は書き込み禁止』『今は書き込み可能』といったフラグのようなものを用意する必要があります。
この手の技術としては、ミューテックス(Mutex)やセマフォ(Semaphore)などがあります。
言語によっては特定の操作の前後にロックをかけるといった方法も用意されることがあります[^lock]。

[^lock]: Pythonでは`threading.Lock`を使うことができます。Javaだと`synchronized`キーワードを使うことができます。

非同期I/Oは比較的最近の技術で、Pythonでは`asyncio`モジュールを使うことで実現できます。