# 暗号化と公開鍵認証メカニズム

私達の生活において、暗号化は日常的に使われるものであり、不可欠なものとなっています。
通信業界においても、暗号化はデータの機密性、完全性、認証を確保するために重要な役割を果たしています。
特に、インターネット上でのデータの送受信においては、暗号化が不可欠です。
暗号化は、データを第三者から保護し、不正アクセスや盗聴を防ぐために使用されます。
また、暗号化は、デジタル署名や認証にも使用され、データの真正性を保証します。

ここではそんな暗号化についての基本的な概念と、公開鍵認証メカニズムについて説明します。

## 暗号化の基本概念

暗号化は、データを特定のアルゴリズムに基づいて変換し、第三者から保護する技術です。

- **平文 (Plaintext)**: 暗号化されていない元のデータ。
- **暗号文 (Ciphertext)**: 暗号化されたデータ。平文を特定のアルゴリズムで変換したもの。
- **暗号化アルゴリズム (Encryption Algorithm)**: 平文を暗号文に変換するための数学的手法。
- 暗号化と復号化
    - **暗号化 (Encryption)**: 平文を暗号文に変換するプロセス。
    - **復号化 (Decryption)**: 暗号文を平文に戻すプロセス。
- **鍵 (Key)**: 暗号化と復号化に使用される秘密の情報。鍵の長さと複雑さは、暗号化の強度に影響します。

## 共通鍵(対称鍵)方式

共通鍵(対称鍵)方式は、同じ鍵で暗号化と復号化を行う方式です。
例えるなら、私達が日常的に使う自宅の鍵や車の鍵がそれで、鍵としての形状は一つであり、所有すれば誰でもその鍵を使って自宅のドアを開けることができます(たとえ見知らぬ他人であっても!)。
このように、同一の鍵を複数の人が共有して利用することで暗号化と復号化を行う方法です。

この概念を用いる暗号化では、一般に「共通鍵(対称鍵)」という表現が用いられます。

- 一般的な暗号化は、この共通鍵方式が広く用いられています。
- 共通鍵方式の例としては、AES (Advanced Encryption Standard) や DES (Data Encryption Standard) などがあります。

## 共通鍵方式のメリット/デメリット

共通鍵(対称鍵)方式は、暗号化と復号化に同じ鍵を使用するため、計算が高速であり、大量のデータを効率的に処理できます。

### メリット(共通鍵方式)

- **高速性**: 共通鍵方式は計算が高速であり、大量のデータを効率的に処理できます。
- **シンプルな実装**: 共通鍵方式はアルゴリズムが比較的シンプルであり、実装が容易です。
- **低い計算コスト**: 共通鍵方式は計算コストが低く、リソースの制約がある環境でも使用できます。

計算コストは、メモリやCPUに制限があったとしても、それなりの性能を保有したまま暗号化/復号化が実行可能な環境かどうかとして表れてきます。また、シンプルな実装はハードウェアロジック(いわゆる回路)としての実装が容易かどうかということも示しており、計算性能を上げる(改善する)という意味では非常に重要とされます。

### デメリット(共通鍵方式)

- **鍵管理の難しさ**: 共通鍵方式では、鍵を安全に共有する必要があり、鍵の管理が難しいです。特に、多数のユーザーがいる場合、鍵の配布と管理が複雑になります。
- **スケーラビリティの問題**: 多数のユーザーがいる場合、各ユーザー間で異なる鍵を共有する必要があり、スケーラビリティの問題が発生します。
- **鍵の漏洩リスク**: 共通鍵が漏洩した場合、すべての通信が危険にさらされます。

共通鍵におけるデメリットはやはり鍵の管理です。安全に鍵を共有する必要があり、鍵の管理が難しいです。特に、多数のユーザーがいる場合、鍵の配布と管理が複雑になります。
多数のユーザーが居ることにより、そこからさらに漏洩のリスクも高まるという危険性もあります。

### 鍵の配送問題とDH鍵交換

共通鍵において、鍵をどのように共有するかは大きな問題となります。
物理的な鍵でももちろん発生する問題ですが、インターネットのような不特定多数がアクセス/共有するような環境においては、鍵を遠方の方にどう渡すかということも検討しないといけません。

そこで登場するのが、Diffie-Hellman鍵交換(DH鍵交換)です。
1976年にWhitfield **Diffie**とMartin **Hellman**によって提案された方法で、共通鍵を安全に共有するためのプロトコルです。
すごく雑に書けば「通信路に計算した値を何回か交換していくことで、最終的に双方が同じ鍵を生成できる」というものです。
この計算では、離散対数問題の難しさを利用しており、第三者が通信を傍受しても、共通鍵を推測することが非常に困難です。

```{note}
離散対数問題とは、ある数値 $ g $ と $ y $ に対して、$ g^x \equiv y \pmod p $ を満たす $ x $ を求める問題です。ここで、$ p $ は素数であり、$ g $ は $ p $ の原始根です。この問題は計算上非常に難しいとされており、これを利用することで安全な鍵交換が可能となります。

⋯と書いてもよくわかりませんよね。いいです、わからなくても⋯

```

### 計算例

おそらくDH鍵交換を理解する上で一番わかりやすいのは、実際に計算してみることです。
ここでは二人の人物、アリス(Alice)とボブ(Bob)がいるとします。
二人の間で暗号化通信を行うために、共通鍵を生成したいと考えています。
実際の計算ではかなり大きな数を扱いますが、今回は計算しやすい値(手計算しやすい値)を使って生成例を説明します。

1. とりあえずアリスの側で、素数と原始根と呼ばれる値を決めます。この値をボブに送信して共有します。
     - 素数 $ p = 23 $
     - 原始根 $ g = 5 $ ※ 原始根が何なのかはここではあまり気にしないでください
1. アリスは秘密の値 $ a = 6 $ を選びます。この値は**アリスだけが知っている秘密の情報**です。
1. アリスは次を計算します。

    $$
    A = g^a \bmod p = 5^6 \bmod 23 = 15625 \bmod 23 = 8
    $$
1. アリスは $ A $ をボブに送ります。あくまでボブに送られるのはAの値である8のみです。

ここまででアリスがボブに送った値は以下のものとなります。

- 素数 $ p = 23 $
- 原始根 $ g = 5 $
- 計算結果 $ A = 8 $

続いてボブ側です。

1. ボブは秘密の値 $ b = 15 $ を選びます。この値は**ボブだけが知っている秘密の情報**です。
1. ボブは次を計算します。

    $$
    B = g^b \bmod p = 5^{15} \bmod 23 = 30517578125 \bmod 23 = 19
    $$
 
1. ボブは $ B $ をアリスに送ります。あくまでアリスに送られるのはBの値である19のみです。


ここまででボブがアリスに送った値は以下のものとなります。

- 計算結果 $ B = 19 $

ここまででアリスとボブはお互いに値のやり取りを行いましたが、それぞれが持つ値を整理してみましょう。

- アリス側
    - 素数 $ p = 23 $
    - 原始根 $ g = 5 $
    - 秘密の値 $ a = 6 $ ※ アリスだけが知っている秘密の情報
    - ボブから受け取った値 $ B = 19 $
- ボブ側
    - 素数 $ p = 23 $
    - 原始根 $ g = 5 $
    - 秘密の値 $ b = 15 $ ※ ボブだけが知っている秘密の情報
    - アリスから受け取った値 $ A = 8 $

ここで共通鍵の生成を行います。共通鍵の生成式は以下のとおりです。

- アリス側での共通鍵生成式: $ s = B^a \bmod p $
- ボブ側での共通鍵生成式: $ s = A^b \bmod p $

それぞれを計算してみましょう。

- アリスの側:

    $$
    s = 19^6 \bmod 23 = 47,045,881 \bmod 23 = 2
    $$

- ボブの側:

    $$
    s = 8^{15} \bmod 23 = 35,184,372,088,832 \bmod 23 = 2
    $$

となり、アリスとボブは同じ共通鍵 $ s = 2 $ を生成することができました。

```{mermaid}
sequenceDiagram
        participant Alice as アリス
        participant Bob as ボブ

        Alice->>Alice: p = 23, g = 5
        Alice->>Alice: a = 6
        Alice->>Alice: A = g^a mod p = 5^6 mod 23 = 8
        Alice->>Bob: p=23, g=5, A=8
        Bob->>Bob: b = 15
    Bob->>Bob: B = g^b mod p = 5^15 mod 23 = 19
    Bob->>Alice: B=19
    Alice->>Alice: s = B^a mod p = 19^6 mod 23 = 2
        Bob->>Bob: s = A^b mod p = 8^15 mod 23 = 2
```


### どうしてこうなった?

アリスがボブに送った値Aについて、もともとの計算はこうなっていました。

$$
A = g^a \bmod p = 5^6 \bmod 23 = 8
$$

ボブの側で、仮にAの値を計算式のままで適用したらどうなるでしょうか。

$$
s = A^b \bmod p = (g^a \bmod p)^b \bmod p = g^{ab} \bmod p = 5^{6\cdot 15} \bmod 23 = 5^{90} \bmod 23 = 2
$$

同様に、ボブがアリスに送った値Bについても、もともとの計算はこうなっていました。

$$
B = g^b \bmod p = 5^{15} \bmod 23 = 19
$$

アリスの側で、仮にBの値を計算式のままで適用したらどうなるでしょうか。

$$
s = B^a \bmod p = (g^b \bmod p)^a \bmod p = g^{ab} \bmod p = 5^{15\cdot 6} \bmod 23 = 5^{90} \bmod 23 = 2
$$

```{note}
途中の式変換が少しわかりにくいかもしれません。

$$
(g^b \bmod p)^a \bmod p = g^{ab} \bmod p
$$

これは、剰余(モジュロ)計算を行うときの重要な操作で、計算の途中で剰余を取っても最終結果は変わらない、という性質を利用しています。

例えば $ 7^7 \bmod 6 $ を考えてみましょう。
素直に計算すれば、 

$$
7^7 \bmod 6 = 823,543 \bmod 6 = 1
$$
となります。
ですが、途中で剰余を取得してみると、 

$$ (7 \bmod 6)^7 \bmod 6 = 1^7 \bmod 6 = 1 \bmod 6 = 1 $$

となり、同じ結果になることがわかります。このように途中で剰余を先に取ることで計算が楽になるケースがあります。

同様に $ 7^6 \bmod 23 $ を考えてみましょう。
素直に計算すれば、 

$$ 7^6 \bmod 23 = 117,649 \bmod 23 = 4 $$ 

となります。ですが、途中で剰余を取得してみると、 

$$ (7 \bmod 23)^6 \bmod 23 = 7^6 \bmod 23 = 4 $$

となり、同じ結果になることがわかります。ただ、この場合は剰余を入れる意味がないように見えますよね。
そこで、 $ 7^6 = 7^{2\cdot 3} = (7^2)^3 $ と変形してみます。
すると、 

$$
7^2 \bmod 23 = 49 \bmod 23 = 3
$$

となるため、

$$
(7^2 \bmod 23)^3 \bmod 23 = 3^3 \bmod 23 = 27 \bmod 23 = 4
$$
となり、同じ結果になることがわかります。

同様に $ 7^7 \bmod 23 $ の場合は、 $ 7^7 = 7^{2\cdot 3 + 1} = (7^2)^3 \cdot 7 $ と変形してみます。
すると、 $ 7^2 \bmod 23 = 49 \bmod 23 = 3 $ となるため、

$$
(7^2 \bmod 23)^3 \cdot (7 \bmod 23) \bmod 23
    = 3^3 \cdot 7 \bmod 23
    = 189 \bmod 23 = 5
$$

となり、真っ正直に計算($ 7^7 \bmod 23 = 823,543 \bmod 23 = 5 $)同じ結果になることがわかります。

このように、若干複雑見えますが、剰余を途中で挟むことにより数値の肥大化を防ぐことができ、計算が楽になる場合があります。

```

ポイントは後半で、 $ 5^{6\cdot 15} $ と $ 5^{15\cdot 6} $ は同じ計算であることです。
このように、アリスとボブはお互いに値を送り合うことで、同じ共通鍵を生成することができました。

この計算例では非常に小さな数を使っていますが、実際には非常に大きな素数と原始根を使用します。
この組み合わせは非常に多くの組み合わせが存在し、第三者が通信を傍受しても、共通鍵を推測することが非常に困難です。

### 補足

DH鍵交換は、共通鍵を安全に合意できるプロトコルです。DH自体に「計算方法の致命的欠陥」が見つかったわけではありませんが、素のDHには認証機構がないため中間者攻撃(MITM)に対して脆弱です。実運用では、デジタル署名や証明書を用いた認証と組み合わせた認証付きDH(例: STS)、あるいはTLSにおけるDHE/ECDHEのようにサーバ証明書で署名する形で利用されます。また、弱いパラメータや古い実装は Logjam などの攻撃の対象となるため、十分なビット長と適切な実装が重要です。

## 公開鍵方式

公開鍵方式とは、暗号化と復号化に異なる鍵を使用する方式です。日常では殆ど見ない形式と思われます。
公開鍵方式では、二つの鍵が存在します。

- **公開鍵 (Public Key)**: 誰でも知ることができる鍵
- **秘密鍵 (Private Key)**: 所有者だけが知ることができる鍵

公開鍵方式には「片方の鍵で行った操作は、もう片方でのみ逆操作できる」という性質があります。ただし実務上は次のように役割を分けて使います。

- 公開鍵で暗号化したデータは、対応する秘密鍵でしか復号化できない(機密性のための暗号化)。
- 秘密鍵で生成した署名は、対応する公開鍵で検証できる(真正性・改ざん検出のための署名)。

そこで、お互いに「公開鍵」を交換すると、相手の公開鍵を使ってメッセージを暗号化し、相手に送信することができます。受け取った側は、自分の秘密鍵を使ってそのメッセージを復号化することができます。
逆に、メッセージそのものではなくそのダイジェスト(ハッシュ)に対して秘密鍵で署名(暗号学的変換)を行うと、対応する公開鍵で検証できます。これは、その秘密鍵の所有者が作成したことの証明(デジタル署名)になります。

これだけ秘密鍵のちからが強い状態のため、第三者に渡っても使えなくするための保護として、パスフレーズを設定して保護していることが大半です。
パスフレーズ(passphrase)は、秘密鍵を使う際に必要な追加のパスワードのようなもので、秘密鍵が第三者に渡ったとしても、パスフレーズがわからなければ秘密鍵を使うことができないようにするためのものです。いわゆるパスワードが「単語(word)」に対し、「フレーズ(phrase)」と呼ばれるように、パスフレーズは複数の単語を組み合わせた長い文字列であることが多く、セキュリティを高めるために使用されます。パスフレーズはわかりやすい単語の組み合わせであったとしても、長い文字列であることが推奨されます。

```{note}
デジタル署名では、メッセージのダイジェスト(SHA-256 などの安全なハッシュ)に対して秘密鍵で署名を行い、受信者は送信者の公開鍵で検証します。MD5 や SHA-1 は衝突耐性が不足しているため新規用途では非推奨です。
```

## 公開鍵方式のメリット/デメリット

公開鍵方式は、暗号化と復号化に異なる鍵を使用するため、鍵の管理が容易であり、スケーラビリティの問題が少ないです。

### メリット(公開鍵方式)

- **鍵管理の容易さ**: 公開鍵方式では、公開鍵を自由に配布できるため、鍵の管理が容易です。秘密鍵は所有者だけが知っているため、漏洩リスクが低減されます。
- **スケーラビリティの向上**: 多数のユーザーがいる場合でも、各ユーザーが自分の公開鍵を配布するだけで済むため、スケーラビリティの問題が少ないです。
- **認証の提供**: 公開鍵方式は、デジタル署名を使用して、送信者の認証を提供できます。

署名は自動ではなく、署名者が手動で行うようにさせることで「意図的に署名をする」という行為がはいります。これにより署名した人は、そのメッセージに対する責任が伴うことにもなります(「否認」の防止)。

```{note}
署名を自動化することは技術的には問題なく行えますが、署名者の責任を曖昧にすることにもなりかねないため、注意が必要です。ただし実際の運用においては、署名の自動化(Webサーバーの証明書など)を行っていることも多いです。
```


### デメリット(公開鍵方式)

一方でデメリットももちろんあります。

- **計算コストの高さ**: 公開鍵方式は計算コストが高く、大量のデータを処理する場合に効率が悪いです。
- **複雑な実装**: 公開鍵方式はアルゴリズムが複雑であり、実装が難しいです。
- **鍵の長さ**: 公開鍵方式では、鍵の長さが長くなる傾向があり、これが計算コストの高さに影響します。

公開鍵方式におけるデメリットは、計算コストの高さです。公開鍵方式は計算コストが高く、大量のデータを処理する場合に効率が悪いです。
また、公開鍵方式はアルゴリズムが複雑であり、実装が難しいです。
さらに、公開鍵方式では、鍵の長さが長くなる傾向があり、これが計算コストの高さに影響します。

そしてなにより「お互いに公開鍵を事前に交換しないといけない」事が面倒と思われることが多いです。

## データ送信と共通鍵/公開鍵の使い方

それぞれにメリットとデメリットがある方式を組み合わせて、以下のような送受信が日夜行われています。

1. 送信者は受信者の公開鍵を使って、共通鍵(セッション鍵)を暗号化します(RSA-OAEP などの鍵カプセル化)。
2. 送信者は共通鍵を使って、メッセージを暗号化します。
3. 送信者は暗号化された共通鍵と暗号化されたメッセージを受信者に送信します。
4. 受信者は自分の秘密鍵を使って、暗号化された共通鍵を復号化します。
5. 受信者は復号化された共通鍵を使って、暗号化されたメッセージを復号化します。

公開鍵暗号のようなコストの高い計算は「鍵配送(鍵の保護)」のみに用い、データ本体は高速な共通鍵暗号で処理します。あるいは、公開鍵で暗号化せずに ECDH/ECDHE などの鍵合意プロトコルで共通鍵を合意する方式も一般的です(TLS 1.3 ではこちらが主流)。

## 暗号化アルゴリズム

これらの暗号化方式には、様々なアルゴリズムが存在します。
ただし歴史的経緯により、現在では仕様が推奨されないものも含まれています。

- 共通鍵暗号のアルゴリズム(一部)
    - DES (Data Encryption Standard) ※ 非推奨
    - 3DES (Triple DES) ※ レガシー(段階的廃止/非推奨)
    - AES (Advanced Encryption Standard)
    - RC4 (Rivest Cipher 4) ※ 非推奨
    - ChaCha20
- 公開鍵暗号のアルゴリズム(一部)
    - RSA (Rivest-Shamir-Adleman) ある意味スタンダード(署名・鍵カプセル化で広く利用。TLS 1.3 では鍵合意は行わない)
    - DSA (Digital Signature Algorithm) 署名専用
    - ECC (Elliptic Curve Cryptography) 楕円曲線暗号、最近はこの系統が比較的主流になりつつあります
        - ECDSA (Elliptic Curve Digital Signature Algorithm)
        - EdDSA (Edwards-curve Digital Signature Algorithm)
        - ECDH / ECDHE (楕円曲線版 Diffie-Hellman：鍵合意)
    - ElGamal ※ 現代ではほぼ使われず非推奨(代替として RSA-OAEP や ECIES など)
    
